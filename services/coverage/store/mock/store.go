package mock

import (
	"github.com/plimble/aloy/services/coverage/entity"
	"github.com/stretchr/testify/mock"
)

// Store is an autogenerated mock type for the Store type
type Store struct {
	mock.Mock
}

// CreateCommit provides a mock function with given fields: commit
func (_m *Store) CreateCommit(commit *entity.Commit) error {
	ret := _m.Called(commit)

	var r0 error
	if rf, ok := ret.Get(0).(func(*entity.Commit) error); ok {
		r0 = rf(commit)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateRepository provides a mock function with given fields: repository
func (_m *Store) CreateRepository(repository *entity.Repository) error {
	ret := _m.Called(repository)

	var r0 error
	if rf, ok := ret.Get(0).(func(*entity.Repository) error); ok {
		r0 = rf(repository)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteCommit provides a mock function with given fields: commitId
func (_m *Store) DeleteCommit(commitId string) error {
	ret := _m.Called(commitId)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(commitId)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteRepositoryAndCommits provides a mock function with given fields: repositoryId
func (_m *Store) DeleteRepositoryAndCommits(repositoryId string) error {
	ret := _m.Called(repositoryId)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(repositoryId)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetAllCommitsByName provides a mock function with given fields: name, limit, offset
func (_m *Store) GetAllCommitsByName(name string, limit int, offset int) ([]*entity.Commit, error) {
	ret := _m.Called(name, limit, offset)

	var r0 []*entity.Commit
	if rf, ok := ret.Get(0).(func(string, int, int) []*entity.Commit); ok {
		r0 = rf(name, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*entity.Commit)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, int, int) error); ok {
		r1 = rf(name, limit, offset)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAllCommitsByRepository provides a mock function with given fields: repositoryId, limit, offset
func (_m *Store) GetAllCommitsByRepository(repositoryId string, limit int, offset int) ([]*entity.Commit, error) {
	ret := _m.Called(repositoryId, limit, offset)

	var r0 []*entity.Commit
	if rf, ok := ret.Get(0).(func(string, int, int) []*entity.Commit); ok {
		r0 = rf(repositoryId, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*entity.Commit)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, int, int) error); ok {
		r1 = rf(repositoryId, limit, offset)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAllCommitsByRepositoryAndRef provides a mock function with given fields: repositoryId, ref, limit, offset
func (_m *Store) GetAllCommitsByRepositoryAndRef(repositoryId string, ref string, limit int, offset int) ([]*entity.Commit, error) {
	ret := _m.Called(repositoryId, ref, limit, offset)

	var r0 []*entity.Commit
	if rf, ok := ret.Get(0).(func(string, string, int, int) []*entity.Commit); ok {
		r0 = rf(repositoryId, ref, limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*entity.Commit)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, int, int) error); ok {
		r1 = rf(repositoryId, ref, limit, offset)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAllRepositorys provides a mock function with given fields: limit, offset
func (_m *Store) GetAllRepositorys(limit int, offset int) ([]*entity.Repository, error) {
	ret := _m.Called(limit, offset)

	var r0 []*entity.Repository
	if rf, ok := ret.Get(0).(func(int, int) []*entity.Repository); ok {
		r0 = rf(limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*entity.Repository)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(int, int) error); ok {
		r1 = rf(limit, offset)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRepository provides a mock function with given fields: repositoryName, repositoryOwnerName, repositorySource
func (_m *Store) GetRepository(repositoryName string, repositoryOwnerName string, repositorySource string) (*entity.Repository, error) {
	ret := _m.Called(repositoryName, repositoryOwnerName, repositorySource)

	var r0 *entity.Repository
	if rf, ok := ret.Get(0).(func(string, string, string) *entity.Repository); ok {
		r0 = rf(repositoryName, repositoryOwnerName, repositorySource)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.Repository)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = rf(repositoryName, repositoryOwnerName, repositorySource)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
